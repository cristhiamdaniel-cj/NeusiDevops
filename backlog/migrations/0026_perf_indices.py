# Generated by Django 5.2.6 on 2025-11-08
from django.db import migrations
from django.db.models import DateField, DateTimeField

def _q(schema_editor, name):
    return schema_editor.quote_name(name)

def _is_concrete_field(f):
    return hasattr(f, "column") and f.column is not None and not f.many_to_many and not f.auto_created

def _field_column(model_class, field_name):
    f = model_class._meta.get_field(field_name)
    return f.column  # respeta db_column

def _fk_column_to(model_class, target_model_class):
    """Busca la columna FK en model_class que apunte a target_model_class."""
    for f in model_class._meta.get_fields():
        if getattr(getattr(f, "remote_field", None), "model", None) is target_model_class:
            return model_class._meta.get_field(f.name).column
    return None

def _first_field_column_by_name_contains(model_class, name_candidates):
    """Devuelve la columna del primer campo cuyo nombre contenga alguno de los candidatos."""
    names = [n.lower() for n in name_candidates]
    for f in model_class._meta.get_fields():
        if _is_concrete_field(f):
            n = getattr(f, "name", "").lower()
            if any(c in n for c in names):
                return f.column
    return None

def _first_date_column(model_class):
    """Primer campo tipo fecha/fecha-hora, útil como fallback."""
    for f in model_class._meta.get_fields():
        if _is_concrete_field(f) and isinstance(getattr(f, "remote_field", None), type(None)):
            if isinstance(getattr(f, "target_field", f), (DateField, DateTimeField)):
                return f.column
    return None

def _columns_exist(schema_editor, table_name, column_names):
    """Verifica que todas las columnas existan (ignorando posibles ' ASC/DESC')."""
    with schema_editor.connection.cursor() as c:
        for col in column_names:
            col_only = col.split()[0]  # quita ordenamientos si vinieran
            c.execute("""
                SELECT 1
                FROM information_schema.columns
                WHERE table_name = %s AND column_name = %s
            """, [table_name, col_only])
            if c.fetchone() is None:
                return False
    return True

def _create_index_if(schema_editor, index_name, table_name, columns):
    if not columns or not _columns_exist(schema_editor, table_name, columns):
        return
    cols_sql = ", ".join(columns)  # columnas ya vienen "quoteadas" abajo
    schema_editor.execute(
        f"CREATE INDEX IF NOT EXISTS {_q(schema_editor, index_name)} "
        f"ON {_q(schema_editor, table_name)} ({cols_sql});"
    )

def create_perf_indexes(apps, schema_editor):
    # Modelos
    Daily     = apps.get_model('backlog', 'Daily')
    DailyItem = apps.get_model('backlog', 'DailyItem')
    Tarea     = apps.get_model('backlog', 'Tarea')
    Subtarea  = apps.get_model('backlog', 'Subtarea')
    Sprint    = apps.get_model('backlog', 'Sprint')
    Proyecto  = apps.get_model('backlog', 'Proyecto')

    # Tablas reales
    tbl_daily     = Daily._meta.db_table
    tbl_dailyitem = DailyItem._meta.db_table
    tbl_tarea     = Tarea._meta.db_table
    tbl_subtarea  = Subtarea._meta.db_table
    tbl_sprint    = Sprint._meta.db_table
    tbl_proyecto  = Proyecto._meta.db_table

    # DAILY: integrante + fecha
    col_daily_integrante = _first_field_column_by_name_contains(Daily, ['integrante', 'persona', 'usuario'])
    try:
        col_daily_fecha = _field_column(Daily, 'fecha')
    except Exception:
        col_daily_fecha = _first_field_column_by_name_contains(Daily, ['fecha', 'date', 'created', 'creado'])
        if not col_daily_fecha:
            col_daily_fecha = _first_date_column(Daily)

    # DAILY ITEM: FKs
    col_dailyitem_daily    = _fk_column_to(DailyItem, Daily)
    col_dailyitem_tarea    = _fk_column_to(DailyItem, Tarea)
    col_dailyitem_subtarea = _fk_column_to(DailyItem, Subtarea)

    # TAREA: sprint, estado, asignado, epica
    col_tarea_sprint  = _fk_column_to(Tarea, Sprint) or _first_field_column_by_name_contains(Tarea, ['sprint'])
    col_tarea_estado  = None
    for name in ('estado', 'status', 'state'):
        try:
            col_tarea_estado = _field_column(Tarea, name)
            break
        except Exception:
            pass
    if not col_tarea_estado:
        col_tarea_estado = _first_field_column_by_name_contains(Tarea, ['estado','status','state'])
    # asignado
    try:
        col_tarea_asignado = _field_column(Tarea, 'asignado_a')
    except Exception:
        col_tarea_asignado = _first_field_column_by_name_contains(Tarea, ['asignado', 'responsable', 'owner'])
    # epica (opcional)
    try:
        col_tarea_epica = _field_column(Tarea, 'epica')
    except Exception:
        col_tarea_epica = _first_field_column_by_name_contains(Tarea, ['epica'])

    # SUBTAREA: FK a Tarea + estado + responsable
    col_subtarea_tarea = _fk_column_to(Subtarea, Tarea) or _first_field_column_by_name_contains(Subtarea, ['tarea','hu','macro'])
    col_subtarea_estado = None
    for name in ('estado', 'status', 'state'):
        try:
            col_subtarea_estado = _field_column(Subtarea, name)
            break
        except Exception:
            pass
    if not col_subtarea_estado:
        col_subtarea_estado = _first_field_column_by_name_contains(Subtarea, ['estado','status','state'])
    try:
        col_subtarea_resp = _field_column(Subtarea, 'responsable')
    except Exception:
        col_subtarea_resp = _first_field_column_by_name_contains(Subtarea, ['respons', 'asignado', 'owner'])

    # SPRINT
    col_sprint_inicio = _first_field_column_by_name_contains(Sprint, ['inicio', 'start'])
    col_sprint_fin    = _first_field_column_by_name_contains(Sprint, ['fin', 'end'])

    # PROYECTO
    try:
        col_proyecto_codigo = _field_column(Proyecto, 'codigo')
    except Exception:
        col_proyecto_codigo = _first_field_column_by_name_contains(Proyecto, ['codigo','code'])

    # ===== Crear índices =====
    # DAILY
    if col_daily_integrante and col_daily_fecha:
        _create_index_if(schema_editor, "idx_backlog_daily_integrante_fecha",
                         tbl_daily, [_q(schema_editor, col_daily_integrante), _q(schema_editor, col_daily_fecha)])
    if col_daily_fecha:
        _create_index_if(schema_editor, "idx_backlog_daily_fecha",
                         tbl_daily, [_q(schema_editor, col_daily_fecha)])

    # DAILY ITEM
    if col_dailyitem_daily:
        _create_index_if(schema_editor, "idx_backlog_dailyitem_daily_id",
                         tbl_dailyitem, [_q(schema_editor, col_dailyitem_daily)])
    if col_dailyitem_tarea:
        _create_index_if(schema_editor, "idx_backlog_dailyitem_tarea",
                         tbl_dailyitem, [_q(schema_editor, col_dailyitem_tarea)])
    if col_dailyitem_subtarea:
        _create_index_if(schema_editor, "idx_backlog_dailyitem_subtarea",
                         tbl_dailyitem, [_q(schema_editor, col_dailyitem_subtarea)])

    # TAREA
    if col_tarea_sprint and col_tarea_estado:
        _create_index_if(schema_editor, "idx_backlog_tarea_sprint_estado",
                         tbl_tarea, [_q(schema_editor, col_tarea_sprint), _q(schema_editor, col_tarea_estado)])
    if col_tarea_asignado and col_tarea_estado:
        _create_index_if(schema_editor, "idx_backlog_tarea_asignado_estado",
                         tbl_tarea, [_q(schema_editor, col_tarea_asignado), _q(schema_editor, col_tarea_estado)])
    if col_tarea_epica:
        _create_index_if(schema_editor, "idx_backlog_tarea_epica",
                         tbl_tarea, [_q(schema_editor, col_tarea_epica)])

    # SUBTAREA
    if col_subtarea_tarea and col_subtarea_estado:
        _create_index_if(schema_editor, "idx_backlog_subtarea_tarea_estado",
                         tbl_subtarea, [_q(schema_editor, col_subtarea_tarea), _q(schema_editor, col_subtarea_estado)])
    if col_subtarea_resp and col_subtarea_estado:
        _create_index_if(schema_editor, "idx_backlog_subtarea_responsable_estado",
                         tbl_subtarea, [_q(schema_editor, col_subtarea_resp), _q(schema_editor, col_subtarea_estado)])

    # SPRINT / PROYECTO
    if col_sprint_inicio and col_sprint_fin:
        _create_index_if(schema_editor, "idx_backlog_sprint_inicio_fin",
                         tbl_sprint, [_q(schema_editor, col_sprint_inicio), _q(schema_editor, col_sprint_fin)])
    if col_proyecto_codigo:
        _create_index_if(schema_editor, "idx_backlog_proyecto_codigo",
                         tbl_proyecto, [_q(schema_editor, col_proyecto_codigo)])

def drop_perf_indexes(apps, schema_editor):
    names = [
        "idx_backlog_daily_integrante_fecha",
        "idx_backlog_daily_fecha",
        "idx_backlog_dailyitem_daily_id",
        "idx_backlog_dailyitem_tarea",
        "idx_backlog_dailyitem_subtarea",
        "idx_backlog_tarea_sprint_estado",
        "idx_backlog_tarea_asignado_estado",
        "idx_backlog_tarea_epica",
        "idx_backlog_subtarea_tarea_estado",
        "idx_backlog_subtarea_responsable_estado",
        "idx_backlog_sprint_inicio_fin",
        "idx_backlog_proyecto_codigo",
    ]
    for n in names:
        schema_editor.execute(f"DROP INDEX IF EXISTS {schema_editor.quote_name(n)};")

class Migration(migrations.Migration):
    dependencies = [
        ('backlog', '0025_daily_actualizado_en_daily_creado_en_daily_sprint_and_more'),
    ]
    operations = [
        migrations.RunPython(create_perf_indexes, reverse_code=drop_perf_indexes),
    ]
